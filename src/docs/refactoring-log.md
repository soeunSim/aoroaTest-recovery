# Vue 리팩터링 설계 회고

본 프로젝트는 (주)아로아랩스 사전 테스트 과제를 기반으로, 개인적으로 구조 개선과 학습을 위해 리팩터링한 버전입니다.  
최초 제출한 [과제 레포지토리](https://github.com/soeunSim/aoroaTest)이며, 해당 과제는 수정 없이 보존되어 있습니다.

- 해당 리팩토링은 개발 모드 기반으로 구현하였습니다.
- Vue 프레임워크에 대한 이해가 부족한 상태에서 과제를 진행하다 보니, 단일 책임 원칙이나 UI 구조 등에서 아쉬운 부분이 많았다고 느꼈습니다.
- 과제를 마친 이후에도 아쉬움이 남아, Vue의 구조와 컴포넌트 설계를 좀 더 깊이 이해하고자 개인적으로 다시 설계하고 구현해보았습니다.

## 주요 개선 내용

- **컴포넌트 역할 분리**: 각 컴포넌트가 고유한 책임만을 가지도록 구조를 정리하였습니다.
- **기능 단위별 커밋 관리**: 구현 내용을 UI 요소 및 기능 단위로 나누어 커밋 내역을 세분화하였습니다.
- **재사용성 고려한 설계**: 컴포넌트를 범용적으로 활용할 수 인터페이스를 구성해보았습니다.

## 컴포넌트 설계 및 리팩터링 과정에서의 고민

### 재사용성을 고려한 설계

초기 `IssueListItem.vue`는 `slot` 기반으로 구현되어 재사용성을 고려한 유연한 구조를 목표로 했습니다.
그러나 실제 구현 결과, 상위 컴포넌트(IssueList.vue)가 렌더링 세부 로직과 스타일을 모두 책임지게 되며, 단일 책임 원칙(SRP) 에 위배되는 구조적 문제가 드러났습니다.

```vue
<!-- 구조만 위임하고 렌더링은 전부 상위에서 제어 중 -->
<IssueListItem :issue="issue">
  <span class="issue-status">{{ issue.status }}</span>
  <p class="issue-title">{{ issue.title }}</p>
  <div>
    <span class="issue-manager">{{ issue.user?.name || '미지정' }}</span> |
    <span class="issue-date">{{ issue.createdAt }}</span>
  </div>
</IssueListItem>
```

이처럼 슬롯 구조를 사용했음에도 불구하고, 실질적인 UI 로직이 상위에 집중되면서 재사용성은 떨어지고 구조적 복잡도만 증가하는 문제가 발생하였습니다.
때문에 IssueListItem.vue는 Issue 데이터를 props로 받아 자체적으로 렌더링하는 방식으로 구조를 전환하였습니다.

### Form에 중복 사용 되는 select 컴포넌트를 재활용 하지 않은 이유

처음에는 담당자 선택(select)과 상태 선택(select) 을 공통 컴포넌트로 분리하여 `BaseSelect` 형태로 구성하려 하였습니다.
그러나 구현 과정에서 두 UI 컴포넌트 간의 **기능적 차이**가 뚜렷하다는 점을 확인하게 되었습니다:

- **담당자 select**는 단순한 선택 UI로, 외부 이벤트 처리나 제약이 필요하지 않았습니다.
- 반면, **상태 select**는 담당자 유무에 따라 선택 가능 여부가 달라지며, 상태 변경 시 추가적인 이벤트 처리도 필요했습니다.

이러한 기능 차이로 인해 하나의 컴포넌트보다, 역할이 분명한 개별 컴포넌트로 유지하는 편이 추후 유지보수에도 편리할 것이라 판단하였습니다.  
따라서 `BaseSelect`로 분리하지 않고 각각 독립적으로 구현하였습니다.

### 이슈 상세 페이지에서의 select 초기값 문제

담당자 `select` 박스에 초기값이 설정되지 않는 문제가 발생하였습니다.
이는 `v-model="userId"`로 바인딩하고 있었음에도 불구하고, 해당 값의 초기 상태가 비어 있었기 때문입니다.

이슈 데이터를 초기화할 때 다음과 같은 코드가 사용되고 있었습니다.

```js
reactive({ ...currentIssue.value })
```

이 방식은 `userId `필드를 포함하지 않기 때문에 `v-model`이 제대로 작동하지 않았습니다.

이에 따라 `formData`를 초기화할 때, `userId`를 명시적으로 추출하여 직접 할당하는 방식으로 수정하였습니다:

```js
userId: currentIssue.value.user?.id || ''
```

이로써 user 객체가 존재하지 않는 경우에도 빈 문자열을 기본값으로 사용하여 안전하게 초기화할 수 있었습니다.

옵셔널 체이닝을 사용하는 방식에 대해 고민했으나, 해당 과제의 특성상 담당자 리스트가 제한적이고 `falsy` 값이 들어올 가능성도 낮다고 판단하여 위와 같은 방식으로 처리하였습니다.

## 향후 개선 계획

- 각 함수가 하나의 순수한 기능만 담당하도록 로직을 세분화하여 리팩터링할 예정입니다.

- 전역 상태 관리(Vuex)의 도입을 통해 컴포넌트 간 상태 공유를 명확히 처리하고자 합니다.

- 향후에는 운영 환경을 고려한 API 연동 및 에러 처리 로직도 구현해볼 계획입니다.
